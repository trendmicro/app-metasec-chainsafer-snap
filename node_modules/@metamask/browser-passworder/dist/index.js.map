{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["export type DetailedEncryptionResult = {\n  vault: string;\n  exportedKeyString: string;\n};\n\nexport type EncryptionResult = {\n  data: string;\n  iv: string;\n  salt?: string;\n};\n\nexport type DetailedDecryptResult = {\n  exportedKeyString: string;\n  vault: unknown;\n  salt: string;\n};\n\nconst EXPORT_FORMAT = 'jwk';\nconst DERIVED_KEY_FORMAT = 'AES-GCM';\nconst STRING_ENCODING = 'utf-8';\n\n/**\n * Encrypts a data object that can be any serializable value using\n * a provided password.\n *\n * @param password - The password to use for encryption.\n * @param dataObj - The data to encrypt.\n * @param key - The CryptoKey to encrypt with.\n * @param salt - The salt to use to encrypt.\n * @returns The encrypted vault.\n */\nexport async function encrypt<R>(\n  password: string,\n  dataObj: R,\n  key?: CryptoKey,\n  salt: string = generateSalt(),\n): Promise<string> {\n  const cryptoKey = key || (await keyFromPassword(password, salt));\n  const payload = await encryptWithKey(cryptoKey, dataObj);\n  payload.salt = salt;\n  return JSON.stringify(payload);\n}\n\n/**\n * Encrypts a data object that can be any serializable value using\n * a provided password.\n *\n * @param password - A password to use for encryption.\n * @param dataObj - The data to encrypt.\n * @param salt - The salt used to encrypt.\n * @returns The vault and exported key string.\n */\nexport async function encryptWithDetail<R>(\n  password: string,\n  dataObj: R,\n  salt = generateSalt(),\n): Promise<DetailedEncryptionResult> {\n  const key = await keyFromPassword(password, salt, true);\n  const exportedKeyString = await exportKey(key);\n  const vault = await encrypt(password, dataObj, key, salt);\n\n  return {\n    vault,\n    exportedKeyString,\n  };\n}\n\n/**\n * Encrypts the provided serializable javascript object using the\n * provided CryptoKey and returns an object containing the cypher text and\n * the initialization vector used.\n *\n * @param key - The CryptoKey to encrypt with.\n * @param dataObj - A serializable JavaScript object to encrypt.\n * @returns The encrypted data.\n */\nexport async function encryptWithKey<R>(\n  key: CryptoKey,\n  dataObj: R,\n): Promise<EncryptionResult> {\n  const data = JSON.stringify(dataObj);\n  const dataBuffer = Buffer.from(data, STRING_ENCODING);\n  const vector = global.crypto.getRandomValues(new Uint8Array(16));\n\n  const buf = await global.crypto.subtle.encrypt(\n    {\n      name: DERIVED_KEY_FORMAT,\n      iv: vector,\n    },\n    key,\n    dataBuffer,\n  );\n\n  const buffer = new Uint8Array(buf);\n  const vectorStr = Buffer.from(vector).toString('base64');\n  const vaultStr = Buffer.from(buffer).toString('base64');\n  return {\n    data: vaultStr,\n    iv: vectorStr,\n  };\n}\n\n/**\n * Given a password and a cypher text, decrypts the text and returns\n * the resulting value.\n *\n * @param password - The password to decrypt with.\n * @param text - The cypher text to decrypt.\n * @param key - The key to decrypt with.\n * @returns The decrypted data.\n */\nexport async function decrypt(\n  password: string,\n  text: string,\n  key?: CryptoKey,\n): Promise<unknown> {\n  const payload = JSON.parse(text);\n  const { salt } = payload;\n\n  const cryptoKey = key || (await keyFromPassword(password, salt));\n\n  const result = await decryptWithKey(cryptoKey, payload);\n  return result;\n}\n\n/**\n * Given a password and a cypher text, decrypts the text and returns\n * the resulting value, keyString, and salt.\n *\n * @param password - The password to decrypt with.\n * @param text - The encrypted vault to decrypt.\n * @returns The decrypted vault along with the salt and exported key.\n */\nexport async function decryptWithDetail(\n  password: string,\n  text: string,\n): Promise<DetailedDecryptResult> {\n  const payload = JSON.parse(text);\n  const { salt } = payload;\n  const key = await keyFromPassword(password, salt, true);\n  const exportedKeyString = await exportKey(key);\n  const vault = await decrypt(password, text, key);\n\n  return {\n    exportedKeyString,\n    vault,\n    salt,\n  };\n}\n\n/**\n * Given a CryptoKey and an EncryptionResult object containing the initialization\n * vector (iv) and data to decrypt, return the resulting decrypted value.\n *\n * @param key - The CryptoKey to decrypt with.\n * @param payload - The payload to decrypt, returned from an encryption method.\n * @returns The decrypted data.\n */\nexport async function decryptWithKey<R>(\n  key: CryptoKey,\n  payload: EncryptionResult,\n): Promise<R> {\n  const encryptedData = Buffer.from(payload.data, 'base64');\n  const vector = Buffer.from(payload.iv, 'base64');\n\n  let decryptedObj;\n  try {\n    const result = await crypto.subtle.decrypt(\n      { name: DERIVED_KEY_FORMAT, iv: vector },\n      key,\n      encryptedData,\n    );\n\n    const decryptedData = new Uint8Array(result);\n    const decryptedStr = Buffer.from(decryptedData).toString(STRING_ENCODING);\n    decryptedObj = JSON.parse(decryptedStr);\n  } catch (e) {\n    throw new Error('Incorrect password');\n  }\n\n  return decryptedObj;\n}\n\n/**\n * Receives an exported CryptoKey string and creates a key.\n *\n * @param keyString - The key string to import.\n * @returns A CryptoKey.\n */\nexport async function importKey(keyString: string): Promise<CryptoKey> {\n  const key = await window.crypto.subtle.importKey(\n    EXPORT_FORMAT,\n    JSON.parse(keyString),\n    DERIVED_KEY_FORMAT,\n    true,\n    ['encrypt', 'decrypt'],\n  );\n\n  return key;\n}\n\n/**\n * Receives an exported CryptoKey string, creates a key,\n * and decrypts cipher text with the reconstructed key.\n *\n * @param key - The CryptoKey to export.\n * @returns A key string.\n */\nexport async function exportKey(key: CryptoKey): Promise<string> {\n  const exportedKey = await window.crypto.subtle.exportKey(EXPORT_FORMAT, key);\n  return JSON.stringify(exportedKey);\n}\n\n/**\n * Generate a CryptoKey from a password and random salt.\n *\n * @param password - The password to use to generate key.\n * @param salt - The salt string to use in key derivation.\n * @param exportable - Should the derived key be exportable.\n * @returns A CryptoKey for encryption and decryption.\n */\nexport async function keyFromPassword(\n  password: string,\n  salt: string,\n  exportable = false,\n): Promise<CryptoKey> {\n  const passBuffer = Buffer.from(password, STRING_ENCODING);\n  const saltBuffer = Buffer.from(salt, 'base64');\n\n  const key = await global.crypto.subtle.importKey(\n    'raw',\n    passBuffer,\n    { name: 'PBKDF2' },\n    false,\n    ['deriveBits', 'deriveKey'],\n  );\n\n  const derivedKey = await global.crypto.subtle.deriveKey(\n    {\n      name: 'PBKDF2',\n      salt: saltBuffer,\n      iterations: 10000,\n      hash: 'SHA-256',\n    },\n    key,\n    { name: DERIVED_KEY_FORMAT, length: 256 },\n    exportable,\n    ['encrypt', 'decrypt'],\n  );\n\n  return derivedKey;\n}\n\n/**\n * Converts a hex string into a buffer.\n *\n * @param str - Hex encoded string.\n * @returns The string ecoded as a byte array.\n */\nexport function serializeBufferFromStorage(str: string): Uint8Array {\n  const stripStr = str.slice(0, 2) === '0x' ? str.slice(2) : str;\n  const buf = new Uint8Array(stripStr.length / 2);\n  for (let i = 0; i < stripStr.length; i += 2) {\n    const seg = stripStr.substr(i, 2);\n    buf[i / 2] = parseInt(seg, 16);\n  }\n  return buf;\n}\n\n/**\n * Converts a buffer into a hex string ready for storage.\n *\n * @param buffer - Buffer to serialize.\n * @returns A hex encoded string.\n */\nexport function serializeBufferForStorage(buffer: Uint8Array): string {\n  let result = '0x';\n  buffer.forEach((value) => {\n    result += unprefixedHex(value);\n  });\n  return result;\n}\n\n/**\n * Converts a number into hex value, and ensures proper leading 0\n * for single characters strings.\n *\n * @param num - The number to convert to string.\n * @returns An unprefixed hex string.\n */\nfunction unprefixedHex(num: number): string {\n  let hex = num.toString(16);\n  while (hex.length < 2) {\n    hex = `0${hex}`;\n  }\n  return hex;\n}\n\n/**\n * Generates a random string for use as a salt in CryptoKey generation.\n *\n * @param byteCount - The number of bytes to generate.\n * @returns A randomly generated string.\n */\nexport function generateSalt(byteCount = 32): string {\n  const view = new Uint8Array(byteCount);\n  global.crypto.getRandomValues(view);\n  // Uint8Array is a fixed length array and thus does not have methods like pop, etc\n  // so TypeScript complains about casting it to an array. Array.from() works here for\n  // getting the proper type, but it results in a functional difference. In order to\n  // cast, you have to first cast view to unknown then cast the unknown value to number[]\n  // TypeScript ftw: double opt in to write potentially type-mismatched code.\n  const b64encoded = btoa(\n    String.fromCharCode.apply(null, view as unknown as number[]),\n  );\n  return b64encoded;\n}\n"]}